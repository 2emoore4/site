// Generated by CoffeeScript 1.6.3
(function() {
  window.UTIL = {};

  /**
  * Class to hold coordinates of a three dimensional point.
  */


  UTIL.vertex = (function() {
    function vertex(x, y, z) {
      this.coordinates = [x, y, z];
    }

    vertex.prototype.set = function(pos, value) {
      return this.coordinates[pos] = value;
    };

    return vertex;

  })();

  /**
  * Class to hold collection of vertices which are connected to make a single face.
  */


  UTIL.face = (function() {
    function face(zero, one, two, three) {
      this.vertices = [zero, one, two, three];
    }

    face.prototype.set = function(pos, vertex) {
      return this.vertices[pos] = vertex;
    };

    face.prototype.get_vertex = function(pos) {
      return this.vertices[pos];
    };

    face.prototype.length = function() {
      return this.vertices.length;
    };

    return face;

  })();

  /**
  * Collection of attributes of a 3d geometry and functions to transform them.
  */


  UTIL.geometry = (function() {
    function geometry() {
      this.mesh_m = 10;
      this.mesh_n = 10;
      this.vertices = new Array();
      this.faces = new Array();
      this.matrix = mat4.create();
      this.glob_matrix = mat4.create();
      this.children = new Array();
      this.t = mat4.create();
    }

    /**
    * Multiplies this geometry's global matrix by its parent's global matrix. This ensures that
    * all of the parent geometry's transformations are corrently applied to this geometry.
    * @param {UTIL.geometry} parent geometry
    */


    geometry.prototype.transform_by_parent = function(parent) {
      mat4.copy(this.glob_matrix, parent.glob_matrix);
      return mat4.multiply(this.glob_matrix, this.glob_matrix, this.matrix);
    };

    /**
    * Factory method to create cube primitive.
    * @return {UTIL.geometry} this geometry
    */


    geometry.prototype.cube = function() {
      this.vertices = [new UTIL.vertex(-1, -1, 1), new UTIL.vertex(1, -1, 1), new UTIL.vertex(1, 1, 1), new UTIL.vertex(-1, 1, 1), new UTIL.vertex(-1, 1, -1), new UTIL.vertex(1, 1, -1), new UTIL.vertex(1, -1, -1), new UTIL.vertex(-1, -1, -1), new UTIL.vertex(-1, 1, 1), new UTIL.vertex(1, 1, 1), new UTIL.vertex(1, 1, -1), new UTIL.vertex(-1, 1, -1), new UTIL.vertex(-1, -1, 1), new UTIL.vertex(-1, -1, -1), new UTIL.vertex(1, -1, -1), new UTIL.vertex(1, -1, 1), new UTIL.vertex(1, -1, 1), new UTIL.vertex(1, -1, -1), new UTIL.vertex(1, 1, -1), new UTIL.vertex(1, 1, 1), new UTIL.vertex(-1, -1, -1), new UTIL.vertex(-1, -1, 1), new UTIL.vertex(-1, 1, 1), new UTIL.vertex(-1, 1, -1)];
      this.faces = [new UTIL.face(0, 1, 2, 3), new UTIL.face(4, 5, 6, 7), new UTIL.face(8, 9, 10, 11), new UTIL.face(12, 13, 14, 15), new UTIL.face(16, 17, 18, 19), new UTIL.face(20, 21, 22, 23)];
      return this;
    };

    /**
    * Factory method to create sphere primitive.
    * @return {UTIL.geometry} this geometry
    */


    geometry.prototype.sphere = function() {
      var m, n, u, v, x, y, z, _i, _j, _ref, _ref1;
      this.vertices = new Array((this.mesh_m + 1) * (this.mesh_n + 1));
      this.faces = new Array(this.mesh_m * this.mesh_n);
      this.mesh_to_faces();
      for (m = _i = 0, _ref = this.mesh_m + 1; 0 <= _ref ? _i < _ref : _i > _ref; m = 0 <= _ref ? ++_i : --_i) {
        for (n = _j = 0, _ref1 = this.mesh_n + 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; n = 0 <= _ref1 ? ++_j : --_j) {
          u = m / this.mesh_m;
          v = n / this.mesh_n;
          x = Math.cos(2 * Math.PI * u) * Math.cos(Math.PI * (v - 0.5));
          y = Math.sin(2 * Math.PI * u) * Math.cos(Math.PI * (v - 0.5));
          z = Math.sin(Math.PI * (v - 0.5));
          this.vertices[this.point_to_vertex(m, n)] = new UTIL.vertex(x, y, z);
        }
      }
      return this;
    };

    /**
    * Factory method to create torus primitive.
    * @param {number} outer radius
    * @param {number} inner radius
    * @return {UTIL.geometry} this geometry
    */


    geometry.prototype.torus = function(big_r, little_r) {
      var m, n, u, v, x, y, z, _i, _j, _ref, _ref1;
      this.vertices = new Array((this.mesh_m + 1) * (this.mesh_n + 1));
      this.faces = new Array(this.mesh_m * this.mesh_n);
      this.mesh_to_faces();
      for (m = _i = 0, _ref = this.mesh_m + 1; 0 <= _ref ? _i < _ref : _i > _ref; m = 0 <= _ref ? ++_i : --_i) {
        for (n = _j = 0, _ref1 = this.mesh_n + 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; n = 0 <= _ref1 ? ++_j : --_j) {
          u = m / this.mesh_m;
          v = n / this.mesh_n;
          x = Math.cos(2 * Math.PI * u) * (big_r + little_r * Math.cos(2 * Math.PI * v));
          y = Math.sin(2 * Math.PI * u) * (big_r + little_r * Math.cos(2 * Math.PI * v));
          z = little_r * Math.sin(2 * Math.PI * v);
          this.vertices[this.point_to_vertex(m, n)] = new UTIL.vertex(x, y, z);
        }
      }
      return this;
    };

    /**
    * Factory method to create cylinder primitive.
    * @return {UTIL.geometry} this geometry
    */


    geometry.prototype.cylinder = function() {
      var m, n, u, v, x, y, z, _i, _j, _ref, _ref1;
      this.vertices = new Array((this.mesh_m + 1) * (this.mesh_n + 1));
      this.faces = new Array(this.mesh_m * this.mesh_n);
      this.mesh_to_faces();
      for (m = _i = 0, _ref = this.mesh_m + 1; 0 <= _ref ? _i < _ref : _i > _ref; m = 0 <= _ref ? ++_i : --_i) {
        for (n = _j = 0, _ref1 = this.mesh_n + 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; n = 0 <= _ref1 ? ++_j : --_j) {
          u = m / this.mesh_m;
          v = n / this.mesh_n;
          x = Math.cos(2 * Math.PI * u) * this.r(v);
          y = Math.sin(2 * Math.PI * u) * this.r(v);
          z = 0;
          if (v < 0.5) {
            z = -1;
          } else {
            z = 1;
          }
          this.vertices[this.point_to_vertex(m, n)] = new UTIL.vertex(x, y, z);
        }
      }
      return this;
    };

    /**
    * Helper function for cylinder factory. Determines if a given vertex is on the outer
    * cap of the cylinder.
    * @return {number} 1 if on cap, 0 if not on cap
    */


    geometry.prototype.r = function(v) {
      if (v === 0 || v === 1) {
        return 0;
      } else {
        return 1;
      }
    };

    /**
    * Groups vertices into faces based on the order which they were created by one of
    * the factory methods.
    */


    geometry.prototype.mesh_to_faces = function() {
      var current_face, m, n, _i, _ref, _results;
      _results = [];
      for (m = _i = 0, _ref = this.mesh_m; 0 <= _ref ? _i < _ref : _i > _ref; m = 0 <= _ref ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref1, _results1;
          _results1 = [];
          for (n = _j = 0, _ref1 = this.mesh_n; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; n = 0 <= _ref1 ? ++_j : --_j) {
            current_face = m + (this.mesh_m * n);
            _results1.push(this.faces[current_face] = new UTIL.face(this.point_to_vertex(m, n), this.point_to_vertex(m + 1, n), this.point_to_vertex(m + 1, n + 1), this.point_to_vertex(m, n + 1)));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    /**
    * Converts a given point on the mesh to the index of that point in the vertex array.
    * @return {number} index of vertex in array
    */


    geometry.prototype.point_to_vertex = function(m, n) {
      return m + ((this.mesh_m + 1) * n);
    };

    /**
    * @return {boolean} true if this geometry contains any vertices, else false.
    */


    geometry.prototype.has_vertex = function() {
      if (this.vertices.length === 0) {
        return false;
      } else {
        return true;
      }
    };

    /**
    * Adds a given geometry to list of children.
    */


    geometry.prototype.add = function(child) {
      return this.children.push(child);
    };

    /**
    * Finds and removes a given geometry from list of children.
    */


    geometry.prototype.remove = function(child) {
      var index;
      index = this.children.indexOf(child);
      return this.children = this.children.splice(index, 1);
    };

    /**
    * Incremental translation. Adds to current translation.
    */


    geometry.prototype.translate = function(x, y, z) {
      mat4.identity(this.t);
      mat4.translate(this.t, this.t, [x, y, z]);
      return mat4.multiply(this.matrix, this.matrix, this.t);
    };

    /**
    * Incremental rotation. Adds to current rotation.
    */


    geometry.prototype.rotate_x = function(a) {
      mat4.identity(this.t);
      mat4.rotateX(this.t, this.t, a);
      return mat4.multiply(this.matrix, this.matrix, this.t);
    };

    /**
    * Incremental rotation. Adds to current rotation.
    */


    geometry.prototype.rotate_y = function(a) {
      mat4.identity(this.t);
      mat4.rotateY(this.t, this.t, a);
      return mat4.multiply(this.matrix, this.matrix, this.t);
    };

    /**
    * Incremental rotation. Adds to current rotation.
    */


    geometry.prototype.rotate_z = function(a) {
      mat4.identity(this.t);
      mat4.rotateZ(this.t, this.t, a);
      return mat4.multiply(this.matrix, this.matrix, this.t);
    };

    /**
    * Incremental scale. Multiplies to current scale.
    */


    geometry.prototype.scale = function(x, y, z) {
      mat4.identity(this.t);
      mat4.scale(this.t, this.t, [x, y, z]);
      return mat4.multiply(this.matrix, this.matrix, this.t);
    };

    return geometry;

  })();

  /**
  * Holds three vectors which combine to create a 'steady-state' for a geometry. These states
  * can be selected and changed to create seamless transitions between multiple states. All of
  * the transition logic is done in the actual geometry class.
  */


  UTIL.geometry_state = (function() {
    function geometry_state() {
      this.rotate_vec = vec3.create();
      this.translate_vec = vec3.create();
      this.scale_vec = vec3.create();
      vec3.set(this.scale_vec, 1, 1, 1);
    }

    geometry_state.prototype.copy = function() {
      var result;
      result = new UTIL.geometry_state();
      vec3.copy(result.rotate_vec, this.rotate_vec);
      vec3.copy(result.translate_vec, this.translate_vec);
      vec3.copy(result.scale_vec, this.scale_vec);
      return result;
    };

    return geometry_state;

  })();

  /**
  * Collection of attributes of a 2d geometry and functions to transform them.
  */


  UTIL.geometry_2d = (function() {
    function geometry_2d() {
      this.vertices = new Array();
      this.matrix = mat4.create();
      this.glob_matrix = mat4.create();
      this.children = new Array();
      this.t = mat4.create();
      this.rotate_vec = vec3.create();
      this.translate_vec = vec3.create();
      this.scale_vec = vec3.create();
      this.r_diff = vec3.create();
      this.t_diff = vec3.create();
      this.s_diff = vec3.create();
      this.inc_r_diff = vec3.create();
      this.inc_t_diff = vec3.create();
      this.inc_s_diff = vec3.create();
      this.states = new Object();
      this.states["default"] = new UTIL.geometry_state();
    }

    /**
    * Adds two-dimensional vertex to list of vertices, with default z value of 0. All vertices
    * start with this z value, so that they are 'drawn flat'.
    */


    geometry_2d.prototype.add_vertex = function(vertex) {
      return this.vertices.push([vertex[0], vertex[1], 0]);
    };

    /**
    * Transforms geometry back to its default state.
    */


    geometry_2d.prototype.reset_state = function() {
      return this.change_state("default");
    };

    geometry_2d.prototype.create_state = function(state_name) {
      var i, _i, _ref, _results;
      this.states[state_name] = this.states["default"].copy();
      _results = [];
      for (i = _i = 0, _ref = this.children.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(this.children[i].create_state(state_name));
      }
      return _results;
    };

    /**
    * Transforms this gemoetry based on the three vectors contained in the given state. Rather
    * than perform the transformation immediately, it performs a bunch of incremental
    * transitions, so that it appears smooth.
    */


    geometry_2d.prototype.change_state = function(state_name) {
      var i, state, _i, _ref, _results;
      state = this.states[state_name];
      vec3.subtract(this.r_diff, state.rotate_vec, this.rotate_vec);
      vec3.subtract(this.t_diff, state.translate_vec, this.translate_vec);
      vec3.subtract(this.s_diff, state.scale_vec, this.scale_vec);
      vec3.scale(this.inc_r_diff, this.r_diff, 0.05);
      vec3.scale(this.inc_t_diff, this.t_diff, 0.05);
      vec3.scale(this.inc_s_diff, this.s_diff, 0.05);
      
        for (i = 0; i < 20; i++) {
            (function(r, rd, t, td, s, sd) {
                setTimeout(function() {
                    vec3.add(r, r, rd);
                    vec3.add(t, t, td);
                    vec3.add(s, s, sd);
                }, 10 * i);
            }).call(this, this.rotate_vec, this.inc_r_diff, this.translate_vec, this.inc_t_diff, this.scale_vec, this.inc_s_diff);
        }
        ;
      _results = [];
      for (i = _i = 0, _ref = this.children.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(this.children[i].change_state(state_name));
      }
      return _results;
    };

    /**
    * Multiplies this geometry's global matrix by its parent's global matrix. This ensures that
    * all of the parent geometry's transformations are corrently applied to this geometry.
    * @param {UTIL.geometry} parent geometry
    */


    geometry_2d.prototype.transform_by_parent = function(parent) {
      mat4.copy(this.glob_matrix, parent.glob_matrix);
      return mat4.multiply(this.glob_matrix, this.glob_matrix, this.matrix);
    };

    /**
    * Sets current transformation matrix based on this geometry's global translation,
    * rotation, and scale vectors.
    */


    geometry_2d.prototype.render_prep = function() {
      mat4.identity(this.matrix);
      if (this.translate_vec[0] !== 0 || this.translate_vec[1] !== 0 || this.translate_vec[2] !== 0) {
        mat4.identity(this.t);
        mat4.translate(this.t, this.t, this.translate_vec);
        mat4.multiply(this.matrix, this.matrix, this.t);
      }
      if (this.rotate_vec[0] !== 0) {
        mat4.identity(this.t);
        mat4.rotateX(this.t, this.t, this.rotate_vec[0]);
        mat4.multiply(this.matrix, this.matrix, this.t);
      }
      if (this.rotate_vec[1] !== 0) {
        mat4.identity(this.t);
        mat4.rotateY(this.t, this.t, this.rotate_vec[1]);
        mat4.multiply(this.matrix, this.matrix, this.t);
      }
      if (this.rotate_vec[2] !== 0) {
        mat4.identity(this.t);
        mat4.rotateZ(this.t, this.t, this.rotate_vec[2]);
        mat4.multiply(this.matrix, this.matrix, this.t);
      }
      if (this.scale_vec[0] !== 1 || this.scale_vec[1] !== 1 || this.scale_vec[2] !== 1) {
        mat4.identity(this.t);
        mat4.scale(this.t, this.t, this.scale_vec);
        return mat4.multiply(this.matrix, this.matrix, this.t);
      }
    };

    /**
    * @return {boolean} true if this geometry contains any vertices, else false.
    */


    geometry_2d.prototype.has_vertex = function() {
      if (this.vertices.length === 0) {
        return false;
      } else {
        return true;
      }
    };

    /**
    * Adds a given geometry to list of children.
    */


    geometry_2d.prototype.add = function(child) {
      return this.children.push(child);
    };

    /**
    * Finds and removes a given geometry from list of children.
    */


    geometry_2d.prototype.remove = function(child) {
      var index;
      index = this.children.indexOf(child);
      return this.children = this.children.splice(index, 1);
    };

    /**
    * Absolute translation. Equivalant of resetting matrix and translating.
    */


    geometry_2d.prototype.set_translation = function(x, y, z) {
      return vec3.set(this.translate_vec, x, y, z);
    };

    /**
    * Incremental translation. Adds to current translation.
    */


    geometry_2d.prototype.translate = function(x, y, z) {
      this.translate_vec[0] += x;
      this.translate_vec[1] += y;
      return this.translate_vec[2] += z;
    };

    /**
    * Absolute rotation. Equivalent of resetting matrix and rotating.
    */


    geometry_2d.prototype.set_rotation_x = function(a) {
      return this.rotate_vec[0] = a;
    };

    /**
    * Incremental rotation. Adds to current rotation.
    */


    geometry_2d.prototype.rotate_x = function(a) {
      return this.rotate_vec[0] += a;
    };

    /**
    * Absolute rotation. Equivalent of resetting matrix and rotating.
    */


    geometry_2d.prototype.set_rotation_y = function(a) {
      return this.rotate_vec[1] = a;
    };

    /**
    * Incremental rotation. Adds to current rotation.
    */


    geometry_2d.prototype.rotate_y = function(a) {
      return this.rotate_vec[1] += a;
    };

    /**
    * Absolute rotation. Equivalent of resetting matrix and rotating.
    */


    geometry_2d.prototype.set_rotation_z = function(a) {
      return this.rotate_vec[2] = a;
    };

    /**
    * Incremental rotation. Adds to current rotation.
    */


    geometry_2d.prototype.rotate_z = function(a) {
      return this.rotate_vec[2] += a;
    };

    /**
    * Incremental scale. Multiplies to current scale.
    */


    geometry_2d.prototype.scale = function(x, y, z) {
      this.scale_vec[0] *= x;
      this.scale_vec[1] *= y;
      return this.scale_vec[2] *= z;
    };

    /**
    * Absolute scale. Equivalent of resetting matrix and scaling.
    */


    geometry_2d.prototype.set_scale = function(x, y, z) {
      this.scale_vec[0] = x;
      this.scale_vec[1] = y;
      return this.scale_vec[2] = z;
    };

    return geometry_2d;

  })();

  UTIL.renderer = (function() {
    function renderer(g, w, h) {
      this.g = g;
      this.w = w;
      this.h = h;
      this.world = new UTIL.geometry();
      this.FL = 4;
      this.point0 = vec3.create();
      this.point1 = vec3.create();
      this.a = vec2.create();
      this.b = vec2.create();
      this.temp = vec4.create();
      this.t = mat4.create();
      this.frame = 0;
    }

    /**
    * Renders all geometries.
    */


    renderer.prototype.render_world = function() {
      this.render_geometry(this.world);
      return this.frame += 1;
    };

    renderer.prototype.render_geometry = function(geo) {
      if (geo instanceof UTIL.geometry) {
        return this.render_3d(geo);
      } else if (geo instanceof UTIL.geometry_2d) {
        geo.render_prep();
        return this.render_2d(geo);
      }
    };

    /**
    * Renders a 2d geometry by performing matrix transformations and projecting 3d points
    * to 2d window space. Then renders all children of this geometry.
    */


    renderer.prototype.render_2d = function(geo) {
      var child, i, _i, _j, _len, _ref, _ref1, _results;
      if (geo.has_vertex()) {
        for (i = _i = 1, _ref = geo.vertices.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
          this.transform(geo.glob_matrix, geo.vertices[i - 1], this.point0);
          this.transform(geo.glob_matrix, geo.vertices[i], this.point1);
          this.project_point(this.point0, this.a);
          this.project_point(this.point1, this.b);
          this.draw_line(this.a, this.b);
        }
      }
      _ref1 = geo.children;
      _results = [];
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        child = _ref1[_j];
        child.transform_by_parent(geo);
        _results.push(this.render_geometry(child));
      }
      return _results;
    };

    /**
    * Renders a 3d geometry by performing matrix transformations and projecting 3d points
    * to 2d window space. Then renders all children of this geometry.
    */


    renderer.prototype.render_3d = function(geo) {
      var child, e, f, i, j, _i, _j, _k, _len, _ref, _ref1, _ref2, _results;
      if (geo.has_vertex()) {
        for (f = _i = 0, _ref = geo.faces.length; 0 <= _ref ? _i < _ref : _i > _ref; f = 0 <= _ref ? ++_i : --_i) {
          for (e = _j = 0, _ref1 = geo.faces[f].length() - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; e = 0 <= _ref1 ? ++_j : --_j) {
            i = geo.faces[f].vertices[e];
            j = geo.faces[f].vertices[e + 1];
            this.transform(geo.glob_matrix, geo.vertices[i].coordinates, this.point0);
            this.transform(geo.glob_matrix, geo.vertices[j].coordinates, this.point1);
            this.project_point(this.point0, this.a);
            this.project_point(this.point1, this.b);
            this.draw_line(this.a, this.b);
          }
          i = geo.faces[f].vertices[geo.faces[f].length() - 1];
          j = geo.faces[f].vertices[0];
          this.transform(geo.glob_matrix, geo.vertices[i].coordinates, this.point0);
          this.transform(geo.glob_matrix, geo.vertices[j].coordinates, this.point1);
          this.project_point(this.point0, this.a);
          this.project_point(this.point1, this.b);
          this.draw_line(this.a, this.b);
        }
      }
      _ref2 = geo.children;
      _results = [];
      for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
        child = _ref2[_k];
        child.transform_by_parent(geo);
        _results.push(this.render_geometry(child));
      }
      return _results;
    };

    renderer.prototype.transform = function(mat, src, dst) {
      var i, j, replacement, _i, _j, _k, _ref, _results;
      if (src.length === !dst.length) {
        return console.log("not able to transform point due to dimension error.");
      } else {
        for (i = _i = 0, _ref = src.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          this.temp[i] = src[i];
        }
        this.temp[src.length] = 1;
        _results = [];
        for (i = _j = 0; _j < 3; i = ++_j) {
          replacement = 0.0;
          for (j = _k = 0; _k < 4; j = ++_k) {
            replacement += this.temp[j] * mat[i + (4 * j)];
          }
          _results.push(dst[i] = replacement);
        }
        return _results;
      }
    };

    /**
    * Given two points, returns a list of points that lie on the line which connects those
    * two points.
    */


    renderer.prototype.sub_points = function(last_point, point) {
      var all_points, high, length, low, mid;
      mid = [(point[0] + last_point[0]) / 2, (point[1] + last_point[1]) / 2];
      length = vec2.distance(last_point, point);
      all_points = null;
      if (length < 50) {
        all_points = new Array;
        all_points.push(point);
      } else {
        low = this.sub_points(last_point, mid);
        high = this.sub_points(mid, point);
        all_points = low.concat(high);
      }
      return all_points;
    };

    /**
    * Draws a line between two points. This line is not straight because it adds some noise
    * to the endpoints and to the points in between.
    */


    renderer.prototype.draw_line = function(p1, p2) {
      var i, inter_points, _i, _ref, _results;
      this.g.moveTo(p1[0] + this.noise(), p1[1] + this.noise());
      inter_points = this.sub_points(p1, p2);
      _results = [];
      for (i = _i = 0, _ref = inter_points.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push(this.g.lineTo(inter_points[i][0] + this.noise(), inter_points[i][1] + this.noise()));
      }
      return _results;
    };

    /**
    * Projects a three dimensional point onto a two dimensional window space.
    */


    renderer.prototype.project_point = function(xyz, pxy) {
      var x, y, z;
      x = xyz[0];
      y = xyz[1];
      z = xyz[2];
      pxy[0] = this.w / 2 + (this.h * x / (this.FL - z));
      return pxy[1] = this.h / 2 + (this.h * y / (this.FL - z));
    };

    renderer.prototype.noise = function() {
      return (Math.random() - 0.5) * 2;
    };

    /**
    * Incremental translation of 'world' geometry. Simulates moving the camera.
    */


    renderer.prototype.translate = function(x, y, z) {
      mat4.identity(this.t);
      mat4.translate(this.t, this.t, [x, y, z]);
      return mat4.multiply(this.world.glob_matrix, this.world.glob_matrix, this.t);
    };

    /**
    * Incremental rotation of 'world' geometry. Simulates rotating the camera.
    */


    renderer.prototype.rotate_x = function(a) {
      mat4.identity(this.t);
      mat4.rotateX(this.t, this.t, a);
      return mat4.multiply(this.world.glob_matrix, this.world.glob_matrix, this.t);
    };

    /**
    * Incremental rotation of 'world' geometry. Simulates rotating the camera.
    */


    renderer.prototype.rotate_y = function(a) {
      mat4.identity(this.t);
      mat4.rotateY(this.t, this.t, a);
      return mat4.multiply(this.world.glob_matrix, this.world.glob_matrix, this.t);
    };

    /**
    * Incremental rotation of 'world' geometry. Simulates rotating the camera.
    */


    renderer.prototype.rotate_z = function(a) {
      mat4.identity(this.t);
      mat4.rotateZ(this.t, this.t, a);
      return mat4.multiply(this.world.glob_matrix, this.world.glob_matrix, this.t);
    };

    /**
    * Incremental scale of 'world' geometry. Simulates zooming..
    */


    renderer.prototype.scale = function(x, y, z) {
      mat4.identity(this.t);
      mat4.scale(this.t, this.t, [x, y, z]);
      return mat4.multiply(this.world.glob_matrix, this.world.glob_matrix, this.t);
    };

    return renderer;

  })();

}).call(this);

/*
//@ sourceMappingURL=util.map
*/
